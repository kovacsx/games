Problem (Collatz conjecture also known as "3n + 1" problem):


f(n) : (n / 2) if (n % 2 == 0) else (n * 3 + 1)

The Collatz conjecture is: This process will eventually reach the number 1, regardless of which positive integer is chosen initially. (Wikipedia)

Thus questions:

1. Does "while(n > 1) { n << collatz(n); }; return 1 " will return 1 for every n? (ie. halting problem) 

2. How to estimate the time it takes for an arbitrary number n ("program") to "convolute" to 1. 

3. Give O(f(n)) for any bits of n? -> Depends on n, O(n*log(n)) in "random case" (Answered already?)


1.

Rewrite f assuming p is list that encodes n as a list of bits (0 and 1) that define following operations:

log2(n).....31....0 - bit order

>> - left shift
<< - right shift
[] : {0:1}

and use property that "x * 3" can be rewritten as "x << 1 + x" as "x * 2" is same as "x << 1" 

len(p) = log2(n) (?)

f(p) : (p >> 1) if (p[0] == 0) else (p << 1 + p + 1)


Let's analyze the function:

"Decrease (even) branch" (p[0] == 0) :

p >> 1 : decreases list size by 1, removing "bit" at position 0, thus len(p) decreases by 1

"Increase (odd) branch" (p[0] == 1):

p << 1 + p + 1

	1. p1 := p << 1 - increases list size by 1.
	2. p2 := p1 + p - see explanation below. len(p1) == len(p2) (see below why)
	3. p3 := p2 + 1 - CAN increase list







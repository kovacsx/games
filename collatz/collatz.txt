#
# Proof for Collatz conjecture (ie. 3x + 1 problem) or "The Game of Investigator and Mastermind"
# by Janis Kovalevskis (janis.kovalevskis@gmail.com) (c) 2021, all respective rights apply
#

Problem  statement (Collatz conjecture, known as a "3x + 1 problem"):

f(x) : (x / 2) if (x % 2 == 0) else (x * 3 + 1)

The Collatz conjecture states: This process will eventually reach the number 1, regardless of which positive integer is chosen initially. (Wikipedia)

Thus question thus is:

1. Does f(n) will return 1 for every n eventually? (ie. halting problem) 

Optional:

2. How to estimate the "time" (ie. total iterations) it takes for an arbitrary number n ("program", represented by N bits) to "convolute" to 1. 

3. Is it possible to have O(f(x)) best/worst estimates for any x that can be represented by N bits? -> Depends on n and it's fragmentation, O(N*log(N)) in worst case, O(1) for special cases (Answered already?)

Short version:

"The perpetrator of a crime will bring something into the crime scene and leave with something from it, 
	and that both can be used as forensic evidence" (The Locard's exchange principle)

"Any attempt to remove evidence or run, will in 2 of 3 cases create new evidence. But hey, don't let that stop you!" (Takeshi Kovacs)

Let's reimagine the Collatz problem as the "Game of Investigator and the Mastermind"

The Game of "Investigator and the Mastermind": 

Backstory:

	Mastermind has commited a HEINOUS CRIME!!! The Presidents doughter's favorite puppy has been stolen! 

	Whole country is in terror! Is there nothing saint or impossible for Him?! 

	This must be answered! President requests only the best from the police now!

	It's well known that the crime is performed by the Mastermind, yet how he's exactly connected to the crime is higly elusive, so Police assigns's it's best-of-the-best Investigator on it.. obviously You!

	Mastermind, obviously, has mixed feeling about this and intends always stay 1 step ahead of the police work by trying to mislead the Investigator by tampering with already existing clues and suspects leading to him...

Question remains (drumroll!!!): 

	Will YOU catch the Mastermind or no? Will the speed of YOUR work be enough to catch the Mastermind or he'll always will remain "one step ahead" and on the loose?

Flow of the game:

	Game is played in rounds, with Investigator starting.

	Initially Investigator will collect all the available Clues in front of him to reach the next suspect! (x = x / 2). This will remove 1+ Clues from the game.
	If the suspect in front of the Investigator is Mastermind (ie. x == 1), the game ends and Mastermind has finally to answer for it's crime! Game ends. See ending "Investigator wins".
	If the suspect in front of the Investigator is NOT Mastermind, the Investigator will interview the suspect!

	Interrogation:
		Police questions the suspect (2x) ("Let's take a step back. Tell us what you know!". New Clue appears at position 0)
		Police crossreferences the suspect (+x) ("So if I understand you correctly, everything was like this?")
			Clue in position 0 is turned and becomes a new Suspect. 
			Chain of these events might create "a tip", that will advance Mastermind and leaves a new clue behind.
		"Word goes around" (+1) ("domino effect" -> any Suspects in front of Investigator do become Clues and a new Suspect shows at the end of Clues list).

	Police work continues!

	Mastermind:
		if during interrogation Mastermind receives "a tip", he'll try to cover up a bit more, by leaving a new Clue, behind him.
		For every police interrogation Mastermind will receive AT MOST 1 tip
		During police crossreference we assume the clues / suspects between Investigator and Mastermind will be changed in a rea

Endings:

"Investigator wins": 
	Crime has been solved and the list of evidence linking people and clues, leading to this crime, has been solved! 
	The Mastermind in exchange for a 3 months probation and public work, agrees to return the puppy & never commit crimes again!
	President personally thanks you, You receive a promotion & 100EUR/month salary increase. Great job Sr. Investigator!

"Mastermind wins":
	With police off his back Mastermind successfully evades the punishment and enjoys his frivolous lifestyle for many years to come with zero responsibility as before! 

	Still- by now You've probably have hunch, that there is no such ending, right... right? As police & Investigator will never stop? :)







Explanation:

Let's formalize this as:

I : Investigator
M : Mastermind
- : Clue (0 - in Evidence list)
+ : Suspect (1 - in Evidence list)

Thus for every crime (x) there will be "a trail" of most N Clues/Suspect and it can be written as a following list:

Investigator..{Clues/Suspects}..Mastermind

or short form: "P{+/-}M"









 interrogating the suspect in "front of it" and it's either 

... and split the problem in 2 sub-problems. For simplicity let's call Mastermind "escaping" (List head advances) and Investigatorman "closing in" (List tail advances) and bits (0/1s) between them Obstacles (List itself):

Thus:

0. Interrogate the current suspect "in front of the Investigator". It's either a Suspect or Mastermind (ie. List looks like: "PT" or "P+.....T")
A. Mastermind tries to "escape" by leaving new clues (ie. size of Obstacles increases)
B. Investigatorman tries to catch the Mastermind, by solving clues (ie. size of Obstacles decreases)

Thus the whole chain of Investigator work looks like this:

Investigator -> {Clues / Suspects} -> Mastermind

From there we "map" the algorithm as following:

0. Interrogate the suspect!
	Has Investigator reached the Mastermind? (ie. len(Obstacles) == 0)
A. Investigator checks the clues in front of it to arrive at the next suspect
	(ie. x = x / 2) -> List size decreases by 1. Always. Sometimes by 2+, if more than 1 clue in sequence. (Important!)
B. Mastermind tries to "escape" (x = 3x+1 = 2x + x + 1) -> New clue appears at [0] => Size of Obstacles increases by 1 (Always) ("domino effect") AND _SOMETIMES_ by 1 more  AND it's content changes (ie. old clues become new suspects and current suspects, become clues AND there's an ORDER to it.

Example (3 "clues" between Investigator and a Mastermind:

"P---T" => "P--T" => "P-T" => "PT" => Investigator catches Mastermind!


Universally:

There are always 1 or more suspects in front of the Investigator



Thus we can see all list of potential Clues and Suspects as:

P--+.......T meaning

Investigator starts/continues it's work, by removing clues in front of it (ie. "P--+....T" -> "P+....T")

This is how Investigator removes 1+ clues & arrives at the (next) suspect. During interrogation it's revealed whether it's the theif (ie. no more clues/suspects). Total number of Obstacles is decreased by AT LEAST 1





BUT, it's not that for every A, there's only a single B, as in certain situations (> 1) Investigator advances MORE than 1 obstacle ahead, while Mastermind in ALL BUT ONE situation advances only by 1 obstacle (leaving empty space behind, thus it's ) 



And question will be as follow-

1. Does for any Obstacles between Mastermind and Investigator, Investigator will catch the Mastermind or Mastermind will succesfully escape (or at least keep distance same. Running for life... hard! :D )


Now, lets analyze speed of Investigatorman ("Tail") and Mastermind ("Head")

"Movement" of Investigatorman: 

1. Investigatorman ALWAYS will advance by AT LEAST 1 position


Proof: list will always be in form 1..[01]...1 ("trailing ")








Long version:


	

Axiomatically: Every number can be represented as a sequence (List) of binary bits (1's and 0's), thus number, say 20, is represented as '0010100' for bits 1,2,4,8,16 ((1 * 0) + (2 * 0) + (4 * 1) + (8 * 0) + (16 * 1) (little-endianness). List has Head and Tail.


1.

Let's think bit differently of the problem- 

First transform the n from a number to as a sequence of N-bits (n requires at most log2(n)+1 bits)















Rewrite f assuming p is list that encodes n as a list of bits (0 and 1) that define following operations:

0.... 31 .... log2(n) + 1 - bit order / bits

pop - decrease list size by 1
push - increase list size by 1
[] : {0:1}

and use property that "x * 3" can be rewritten as "x << 1 + x" as "x * 2" is same as "x << 1" 

len(p) = log2(n) (?)

f(p) : (p >> 1) if (p[0] == 0) else (p << 1 + p + 1)


Let's analyze the function:

"Decrease (even) branch" (p[0] == 0) :

pop(p) : decreases list size by 1, removing "bit" at position 0, thus len(p) decreases by 1

"Increase (odd) branch" (p[0] == 1):

p << 1 + p + 1

	1. p1 := push(p) - increases list size by 1.
	2. p2 := p1 + p - see explanation below. len(p1) == len(p2) (see below why)
	3. p3 := p2 + 1 - CAN increase list






